<!-- Generated by SpecStory -->

# 简化Server实例通信的MockMcp类 (2025-04-20 12:03:12)

_**User**_

@server.py @types.py @context.py @exceptions.py @session.py 
我基于Server类实现了很多个实例，在使用这些实例时，我需要调用run启动一个进程，然后再在另一个文件实现一个client代码。现在我希望简化这过程、去除这些通信过程，请帮我实现一个MockMcp类，并实现一个映射函数将Sever类映射成MockMcp类，然后我能使用MockMcp类通过函数直接调用使用工具

---

_**Assistant**_



---

好的，没问题。为了实现在无需启动服务器和客户端通信的情况下直接调用 `Server` 中定义的处理函数（特别是 `call_tool`），我们可以创建一个 `MockMcp` 类。这个类将存储 `Server` 实例注册的处理器，并提供直接调用的方法。

我们将在一个新的文件中创建这个 `MockMcp` 类和映射函数。

**1. 创建 `MockMcp` 类和映射函数**

我将创建一个名为 `mock_mcp.py` 的新文件，并在其中实现 `MockMcp` 类和 `map_server_to_mock` 函数。

```python:mock_mcp.py
from __future__ import annotations as _annotations

import contextvars
from typing import Any, TypeVar, Callable, Awaitable, Generic, Iterable
from collections.abc import AsyncIterator
from contextlib import asynccontextmanager, AbstractAsyncContextManager
import warnings
import logging

import mcp.types as types
from mcp.server.lowlevel.server import Server, request_ctx, _ping_handler, LifespanResultT
from mcp.shared.context import RequestContext
from mcp.shared.session import BaseSession, RequestResponder
from mcp.shared.exceptions import McpError
from pydantic import AnyUrl

logger = logging.getLogger(__name__)

# A placeholder Mock Session
class MockSession(BaseSession):
    """A mock session that does nothing, for use with MockMcp."""
    async def send_request(self, request, result_type):
        raise NotImplementedError("MockSession cannot send requests")

    async def send_notification(self, notification):
        logger.debug(f"MockSession received notification (ignored): {notification}")
        # In a mock environment, we might just log or ignore notifications
        pass

    async def _handle_incoming(self, req):
        pass # No incoming messages to handle in the mock


@asynccontextmanager
async def mock_lifespan(server: MockMcp[LifespanResultT]) -> AsyncIterator[object]:
    """Default lifespan context manager for MockMcp that does nothing."""
    yield {}


class MockMcp(Generic[LifespanResultT]):
    """
    A mock MCP server implementation that allows direct invocation of handlers
    without network communication.
    """
    def __init__(
        self,
        name: str = "mock_server",
        version: str | None = None,
        lifespan_context: LifespanResultT | None = None,
    ):
        self.name = name
        self.version = version
        self.request_handlers: dict[
            type, Callable[..., Awaitable[types.ServerResult]]
        ] = {
            types.PingRequest: _ping_handler, # Keep ping handler for basic check
        }
        self.notification_handlers: dict[type, Callable[..., Awaitable[None]]] = {}
        self._lifespan_context = lifespan_context if lifespan_context is not None else {} # type: ignore
        self._mock_session = MockSession(None, None, types.ClientRequest, types.ClientNotification) # type: ignore

    def _register_request_handler(self, request_type: type, handler: Callable[..., Awaitable[types.ServerResult]]):
        logger.debug(f"MockRegistering handler for {request_type.__name__}")
        self.request_handlers[request_type] = handler

    def _register_notification_handler(self, notification_type: type, handler: Callable[..., Awaitable[None]]):
         logger.debug(f"MockRegistering notification handler for {notification_type.__name__}")
         self.notification_handlers[notification_type] = handler

    async def _call_handler(self, request: types.ServerRequest | Any) -> Any:
        """
        Internal helper to simulate calling a request handler.
        Sets up mock context and extracts the actual result.
        """
        req_type = type(request)
        if req_type not in self.request_handlers:
            raise McpError(types.ErrorData(code=types.METHOD_NOT_FOUND, message=f"Method '{request.method}' not found in mock server")) # type: ignore

        handler = self.request_handlers[req_type]
        token = None
        response = None
        try:
            # Set up a mock context
            mock_request_id = "mock_req_0"
            mock_meta = getattr(request.params, '_meta', None) if getattr(request, 'params', None) else None

            ctx = RequestContext(
                request_id=mock_request_id,
                meta=mock_meta,
                session=self._mock_session, # Use the mock session
                lifespan_context=self._lifespan_context,
            )
            token = request_ctx.set(ctx)

            # Call the handler (which expects the request object and returns ServerResult)
            server_result = await handler(request)

            # Extract the actual result from ServerResult
            if isinstance(server_result, types.ServerResult) and hasattr(server_result.root, 'model_dump'):
                 # Extract the inner result (e.g., ListPromptsResult, CallToolResult)
                 response = server_result.root
            elif isinstance(server_result, types.ServerResult) and server_result.root is None:
                 # Handle cases like Ping where the result is EmptyResult leading to root=None
                 response = None
            else:
                 # Should not happen if handlers adhere to Server class structure
                 logger.warning(f"Handler for {req_type.__name__} returned unexpected type: {type(server_result)}")
                 response = server_result # Or raise error

        except McpError as err:
            # Re-raise MCP errors directly for clarity in mocking
            raise err
        except Exception as err:
            logger.error(f"Error calling mock handler for {req_type.__name__}: {err}", exc_info=True)
            # Simulate error response generation if needed, or just raise
            raise McpError(types.ErrorData(code=types.INTERNAL_ERROR, message=str(err)))
        finally:
            if token:
                request_ctx.reset(token)

        # Further extract specific fields if needed (e.g., from CallToolResult)
        if isinstance(response, types.CallToolResult):
             if response.isError:
                  # Try to extract the error message if available
                  error_text = "Tool execution failed"
                  if response.content and isinstance(response.content[0], types.TextContent):
                       error_text = response.content[0].text
                  raise McpError(types.ErrorData(code=1, message=error_text)) # Using custom code 1 for tool error
             return response.content # Return the actual content list
        elif isinstance(response, types.GetPromptResult):
            return response.messages # Return the messages list
        elif isinstance(response, types.ListPromptsResult):
            return response.prompts
        elif isinstance(response, types.ListToolsResult):
            return response.tools
        elif isinstance(response, types.ListResourcesResult):
            return response.resources
        elif isinstance(response, types.ListResourceTemplatesResult):
            return response.resourceTemplates
        elif isinstance(response, types.ReadResourceResult):
            # The original handler might return ServerResult(ReadResourceResult(...))
            # We need the contents list.
            return response.contents
        elif isinstance(response, types.CompleteResult):
            return response.completion
        elif response is None and req_type is types.PingRequest:
             return None # Ping returns EmptyResult -> None
        elif response is None and (req_type is types.SetLevelRequest or req_type is types.SubscribeRequest or req_type is types.UnsubscribeRequest):
             return None # These also return EmptyResult -> None

        # Fallback or handle other result types
        return response

    # --- Direct Call Methods ---

    async def list_prompts(self) -> list[types.Prompt]:
        request = types.ListPromptsRequest(method="prompts/list", params=None)
        return await self._call_handler(request) # type: ignore

    async def get_prompt(self, name: str, arguments: dict[str, str] | None = None) -> list[types.PromptMessage]:
        params = types.GetPromptRequestParams(name=name, arguments=arguments)
        request = types.GetPromptRequest(method="prompts/get", params=params)
        result: list[types.PromptMessage] = await self._call_handler(request)
        return result

    async def list_tools(self) -> list[types.Tool]:
        request = types.ListToolsRequest(method="tools/list", params=None)
        return await self._call_handler(request) # type: ignore

    async def call_tool(
        self, name: str, arguments: dict | None = None
    ) -> list[types.TextContent | types.ImageContent | types.EmbeddedResource]:
        params = types.CallToolRequestParams(name=name, arguments=arguments or {})
        request = types.CallToolRequest(method="tools/call", params=params)
        result: list[types.TextContent | types.ImageContent | types.EmbeddedResource] = await self._call_handler(request)
        return result

    async def list_resources(self) -> list[types.Resource]:
         request = types.ListResourcesRequest(method="resources/list", params=None)
         return await self._call_handler(request) # type: ignore

    async def list_resource_templates(self) -> list[types.ResourceTemplate]:
         request = types.ListResourceTemplatesRequest(method="resources/templates/list", params=None)
         return await self._call_handler(request) # type: ignore

    async def read_resource(self, uri: AnyUrl) -> list[types.TextResourceContents | types.BlobResourceContents]:
        """Reads a resource and returns the list of contents directly."""
        params = types.ReadResourceRequestParams(uri=uri)
        request = types.ReadResourceRequest(method="resources/read", params=params)
        result: list[types.TextResourceContents | types.BlobResourceContents] = await self._call_handler(request)
        return result

    async def set_logging_level(self, level: types.LoggingLevel) -> None:
        params = types.SetLevelRequestParams(level=level)
        request = types.SetLevelRequest(method="logging/setLevel", params=params)
        await self._call_handler(request)

    async def subscribe_resource(self, uri: AnyUrl) -> None:
        params = types.SubscribeRequestParams(uri=uri)
        request = types.SubscribeRequest(method="resources/subscribe", params=params)
        await self._call_handler(request)

    async def unsubscribe_resource(self, uri: AnyUrl) -> None:
        params = types.UnsubscribeRequestParams(uri=uri)
        request = types.UnsubscribeRequest(method="resources/unsubscribe", params=params)
        await self._call_handler(request)

    async def complete(
        self,
        ref: types.PromptReference | types.ResourceReference,
        argument: types.CompletionArgument,
    ) -> types.Completion:
        params = types.CompleteRequestParams(ref=ref, argument=argument)
        request = types.CompleteRequest(method="completion/complete", params=params)
        result: types.Completion = await self._call_handler(request)
        return result

    async def ping(self) -> None:
        request = types.PingRequest(method="ping", params=None)
        await self._call_handler(request)

    # --- Decorators (for potential direct use with MockMcp) ---
    # These mimic Server's decorators but register handlers directly on MockMcp

    def list_prompts_decorator(self):
        def decorator(func: Callable[[], Awaitable[list[types.Prompt]]]):
            async def handler(_: Any):
                prompts = await func()
                return types.ServerResult(types.ListPromptsResult(prompts=prompts))
            self._register_request_handler(types.ListPromptsRequest, handler)
            return func
        return decorator

    def get_prompt_decorator(self):
        def decorator(
            func: Callable[[str, dict[str, str] | None], Awaitable[types.GetPromptResult]]
        ):
            async def handler(req: types.GetPromptRequest):
                prompt_get = await func(req.params.name, req.params.arguments)
                return types.ServerResult(prompt_get)
            self._register_request_handler(types.GetPromptRequest, handler)
            return func
        return decorator

    # ... Add other decorators similarly if needed ...
    # Example for call_tool decorator:
    def call_tool_decorator(self):
        def decorator(
            func: Callable[
                ..., Awaitable[Iterable[types.TextContent | types.ImageContent | types.EmbeddedResource]]
            ],
        ):
            async def handler(req: types.CallToolRequest):
                try:
                    # Note: Server wraps the call directly. We mimic that.
                    results = await func(req.params.name, (req.params.arguments or {}))
                    return types.ServerResult(
                        types.CallToolResult(content=list(results), isError=False)
                    )
                except Exception as e:
                    # Mimic Server's exception handling for tool calls
                    return types.ServerResult(
                        types.CallToolResult(
                            content=[types.TextContent(type="text", text=str(e))],
                            isError=True,
                        )
                    )
            self._register_request_handler(types.CallToolRequest, handler)
            return func
        return decorator


# --- Mapping Function ---

async def map_server_to_mock(server: Server[LifespanResultT]) -> MockMcp[LifespanResultT]:
    """
    Creates a MockMcp instance from an existing Server instance,
    copying its handlers and lifespan context.
    """
    # Run the server's lifespan to get the context, if it has one other than the default
    lifespan_context: LifespanResultT | object
    if server.lifespan == lifespan: # Check if it's the default do-nothing lifespan
         lifespan_context = {}
    else:
         # Execute the server's lifespan to get the context object
         # We need an async context manager to enter the lifespan
         @asynccontextmanager
         async def get_lifespan_ctx():
              async with server.lifespan(server) as ctx:
                   yield ctx
         async with get_lifespan_ctx() as ctx:
              lifespan_context = ctx


    mock_mcp = MockMcp[LifespanResultT](
        name=f"mock_{server.name}",
        version=server.version,
        lifespan_context=lifespan_context # type: ignore
    )

    # Copy handlers directly - they are already wrapped by the Server decorators
    mock_mcp.request_handlers.update(server.request_handlers)
    mock_mcp.notification_handlers.update(server.notification_handlers)

    logger.info(f"Mapped Server '{server.name}' to MockMcp '{mock_mcp.name}'")
    logger.debug(f"Mock Request Handlers: {list(mock_mcp.request_handlers.keys())}")
    logger.debug(f"Mock Notification Handlers: {list(mock_mcp.notification_handlers.keys())}")

    return mock_mcp
```

**2. 如何使用**

假设你有一个已经配置好的 `Server` 实例：

```python
# existing_server_setup.py
import mcp.types as types
from mcp.server.lowlevel.server import Server
import asyncio

server = Server("my_tool_server")

@server.list_tools()
async def handle_list_tools() -> list[types.Tool]:
    return [
        types.Tool(
            name="calculator",
            description="Performs simple calculations.",
            inputSchema={
                "type": "object",
                "properties": {
                    "expression": {"type": "string", "description": "The math expression"},
                },
                "required": ["expression"],
            },
        )
    ]

@server.call_tool()
async def handle_call_tool(
    name: str, arguments: dict | None
) -> list[types.TextContent | types.ImageContent | types.EmbeddedResource]:
    if name == "calculator":
        if not arguments or "expression" not in arguments:
            raise ValueError("Missing 'expression' argument for calculator")
        try:
            # WARNING: eval is unsafe in real applications! This is just an example.
            result = eval(arguments["expression"], {"__builtins__": {}}, {})
            return [types.TextContent(type="text", text=str(result))]
        except Exception as e:
            raise ValueError(f"Invalid expression: {e}")
    else:
        raise ValueError(f"Unknown tool: {name}")

# ... other handlers ...

# --- Now, instead of running the server, map it to the mock ---
# Note: You need to import the new mock module
from mock_mcp import map_server_to_mock, MockMcp # Assuming mock_mcp.py is in the same directory or python path

async def main():
    # Create the MockMcp instance from the existing server
    mock_server: MockMcp = await map_server_to_mock(server)

    # Now you can call the tool directly
    try:
        print("Calling list_tools...")
        tools = await mock_server.list_tools()
        print(f"Tools: {tools}")

        print("\nCalling calculator tool...")
        expression = "2 + 2 * 3"
        result_content = await mock_server.call_tool("calculator", {"expression": expression})
        print(f"Result of '{expression}': {result_content[0].text}") # Accessing the text directly

        print("\nCalling unknown tool (expecting error)...")
        await mock_server.call_tool("unknown_tool", {})

    except McpError as e:
         print(f"Caught expected MCP Error: {e.error.code} - {e.error.message}")
    except Exception as e:
        print(f"Caught unexpected error: {e}")

if __name__ == "__main__":
    asyncio.run(main())

```

**说明:**

1.  **`MockMcp` 类**:
    *   它有一个 `request_handlers` 字典，就像 `Server` 一样。
    *   它提供 `call_tool`, `list_tools`, `get_prompt` 等 `async` 方法，这些方法接受与原始处理器函数类似的参数（例如，`name` 和 `arguments`）。
    *   在内部，这些方法会：
        *   查找对应的处理器。
        *   构造一个模拟的 MCP 请求对象（如 `types.CallToolRequest`）。
        *   创建一个模拟的 `RequestContext`（包含一个无操作的 `MockSession` 和从服务器 lifespan 获取（如果可能）或默认的 `lifespan_context`），并使用 `contextvars` 设置它，以防处理器内部尝试访问 `request_ctx.get()`。
        *   调用存储在 `request_handlers` 中的处理器（这些处理器是由 `Server` 的装饰器包装过的，它们接受请求对象并返回 `types.ServerResult`）。
        *   从返回的 `types.ServerResult` 中解包出实际结果（例如，从 `CallToolResult` 中提取 `content`）。
        *   处理来自处理器的异常，并将它们（或模拟的工具错误）包装在 `McpError` 中重新抛出。
2.  **`map_server_to_mock` 函数**:
    *   这是一个 `async` 函数，因为它可能需要执行服务器的 `lifespan` 来获取 lifespan 上下文。
    *   它创建一个 `MockMcp` 实例。
    *   它将原始 `Server` 的 `request_handlers` 和 `notification_handlers` 字典直接复制到 `MockMcp` 实例中。因为 `Server` 的装饰器已经将用户函数包装成了接受 MCP 请求对象并返回 `ServerResult` 的形式，所以这些处理器可以直接在 `MockMcp` 的 `_call_handler` 中使用。
    *   它尝试运行服务器的 `lifespan`（如果不是默认的）来获取并传递 `lifespan_context` 给 `MockMcp`。
3.  **使用**: 你现在可以用 `await map_server_to_mock(your_server_instance)` 创建一个 `MockMcp` 对象，然后直接调用如 `await mock_instance.call_tool(...)` 的方法，而不需要运行 `server.run` 或设置客户端。

这种方法重用了 `Server` 类中已经存在的处理器逻辑，减少了代码重复，并提供了一个方便的方式在测试或本地开发中直接与服务器的功能交互。

---

_**User**_

@server.py 请以类似的方法实现MockFastMcp和映射函数，另外我注意到这份代码中的MCPServer就是前面给你的Server，这可能对你有帮助

---

_**Assistant**_



---

Okay, let's implement `MockFastMcp` and the corresponding mapping function `map_fastmcp_to_mock`, similar to what we did for the lower-level `Server` (`MCPServer`).

We'll create these in a new file, say `mock_fastmcp.py` (or you can add them to the existing `mock_mcp.py`).

```python
# Create or append to mock_fastmcp.py

from __future__ import annotations as _annotations

import logging
from typing import Any, TypeVar, Callable, Awaitable, Generic, Iterable, cast
from collections.abc import AsyncIterator
from contextlib import asynccontextmanager, AbstractAsyncContextManager, AsyncExitStack
import datetime
import anyio

import mcp.types as types
from mcp.server.lowlevel.server import LifespanResultT
from mcp.shared.exceptions import McpError
from pydantic.networks import AnyUrl

# Imports from fastmcp needed for mocking/mapping
from fastmcp.server.server import FastMCP, MountedServer, NOT_FOUND, _lifespan_wrapper, default_lifespan
from fastmcp.tools import ToolManager, Tool
from fastmcp.resources import ResourceManager, Resource, ResourceTemplate
from fastmcp.prompts import PromptManager, Prompt
from fastmcp.server.context import Context as FastMCPContext # Alias original context
from fastmcp.exceptions import NotFoundError, ResourceError
from fastmcp.prompts.prompt import PromptResult
from mcp.server.lowlevel.helper_types import ReadResourceContents
from fastmcp.utilities.dependency_injection import solve_dependencies # Needed for context injection


logger = logging.getLogger(__name__)
LifespanResultT = TypeVar("LifespanResultT")


# --- Mock Context ---

class MockContext(Generic[LifespanResultT]):
    """A mock context for FastMCP handlers, providing access to lifespan context."""

    def __init__(self, lifespan_context: LifespanResultT, fastmcp_instance: "MockFastMcp[LifespanResultT]"):
        self._lifespan_context = lifespan_context
        self._fastmcp = fastmcp_instance # Keep ref if needed

    @property
    def lifespan(self) -> LifespanResultT:
        """Access the lifespan context."""
        return self._lifespan_context

    # --- Mocked Context Methods ---
    # Implement methods from FastMCPContext that might be used by handlers

    def debug(self, message: str, **kwargs: Any) -> None:
        logger.debug(f"[MockContext] {message}", extra=kwargs)

    def info(self, message: str, **kwargs: Any) -> None:
        logger.info(f"[MockContext] {message}", extra=kwargs)

    def warning(self, message: str, **kwargs: Any) -> None:
        logger.warning(f"[MockContext] {message}", extra=kwargs)

    def error(self, message: str, **kwargs: Any) -> None:
        logger.error(f"[MockContext] {message}", extra=kwargs)

    async def report_progress(
        self, progress: float, total: float | None = None, token: Any | None = None
    ) -> None:
        # Progress reporting is likely a no-op in mock environment
        logger.debug(f"[MockContext] Progress reported (no-op): progress={progress}, total={total}")
        await anyio.sleep(0) # Simulate async completion

    # Add other methods from FastMCPContext as needed, mocking their behavior.
    # For methods relying on a real session/request (like get_request_meta),
    # they should probably raise NotImplementedError or return None.
    def get_request_meta(self) -> types.RequestParams.Meta | None:
        logger.debug("[MockContext] get_request_meta called (returning None)")
        return None

    def get_request_id(self) -> types.RequestId | None:
        logger.debug("[MockContext] get_request_id called (returning 'mock_req')")
        return "mock_req" # Or None

    # Provide access to the parent mock server instance if needed
    @property
    def server(self) -> "MockFastMcp[LifespanResultT]":
        return self._fastmcp


# --- Mock Timed Cache (Simpler version) ---
class MockTimedCache:
    """A simpler cache for mocking, ignoring expiration."""
    def __init__(self, expiration: datetime.timedelta):
         # Expiration not really used in mock, but kept for signature match
         self._cache: dict[Any, Any] = {}

    def set(self, key: Any, value: Any) -> None:
        self._cache[key] = value

    def get(self, key: Any) -> Any:
        return self._cache.get(key, NOT_FOUND)

    def clear(self) -> None:
        self._cache.clear()


# --- Mock FastMCP ---

class MockFastMcp(Generic[LifespanResultT]):
    """
    A mock FastMCP server implementation that allows direct invocation
    of handlers without network communication.
    """
    def __init__(
        self,
        name: str = "mock_fastmcp",
        instructions: str | None = None,
        lifespan_context: LifespanResultT | None = None,
        tool_manager: ToolManager | None = None,
        resource_manager: ResourceManager | None = None,
        prompt_manager: PromptManager | None = None,
        settings: dict[str, Any] | None = None, # Store settings if needed by handlers via context
        tags: set[str] | None = None,
        dependencies: dict[Callable[..., Any], Any] | None = None, # For context injection
    ):
        self.name = name
        self.instructions = instructions
        self._lifespan_context = lifespan_context if lifespan_context is not None else {} # type: ignore
        self._tool_manager = tool_manager or ToolManager()
        self._resource_manager = resource_manager or ResourceManager()
        self._prompt_manager = prompt_manager or PromptManager()
        self.settings = settings or {} # Store simplified settings
        self.tags = tags or set()
        self.dependencies = dependencies or {} # Store dependencies for injection
        # Use a simple mock cache
        self._cache = MockTimedCache(datetime.timedelta(seconds=60))


    # --- Public API Methods (Mirrors FastMCP) ---

    def get_context(self) -> MockContext[LifespanResultT]:
        """Returns a MockContext object."""
        return MockContext(self._lifespan_context, self)

    async def get_tools(self) -> dict[str, Tool]:
        """Get all registered tools."""
        # In the mock, we assume the map function populates the managers correctly
        # including prefixed items from mounted/imported servers.
        # The cache here is mainly for consistency with FastMCP's interface.
        if (tools := self._cache.get("tools")) is NOT_FOUND:
            tools = self._tool_manager.get_tools()
            self._cache.set("tools", tools)
        return tools

    async def get_resources(self) -> dict[str, Resource]:
        """Get all registered resources."""
        if (resources := self._cache.get("resources")) is NOT_FOUND:
            resources = self._resource_manager.get_resources()
            self._cache.set("resources", resources)
        return resources

    async def get_resource_templates(self) -> dict[str, ResourceTemplate]:
         """Get all registered resource templates."""
         if (templates := self._cache.get("resource_templates")) is NOT_FOUND:
              templates = self._resource_manager.get_templates()
              self._cache.set("templates", templates)
         return templates

    async def get_prompts(self) -> dict[str, Prompt]:
        """Get all registered prompts."""
        if (prompts := self._cache.get("prompts")) is NOT_FOUND:
            prompts = self._prompt_manager.get_prompts()
            self._cache.set("prompts", prompts)
        return prompts


    # --- Direct Call Methods (Simulate calling handlers) ---

    async def call_tool(
        self, key: str, arguments: dict[str, Any] | None = None
    ) -> list[types.TextContent | types.ImageContent | types.EmbeddedResource]:
        """Directly call a tool by key."""
        arguments = arguments or {}
        if not self._tool_manager.has_tool(key):
            raise NotFoundError(f"Unknown tool: {key}")

        context = self.get_context()
        # Use the ToolManager's call_tool which handles context injection via solve_dependencies
        try:
            # Provide the mock context as a possible dependency
            current_dependencies = self.dependencies.copy()
            current_dependencies[MockContext] = context # Allow injection of MockContext

            result = await self._tool_manager.call_tool(
                key,
                arguments,
                context=context, # Pass for ToolManager internal use if needed
                dependencies=current_dependencies # Pass for solve_dependencies
            )

            # Ensure result is in the expected list format (similar to FastMCP handler)
            if not isinstance(result, list):
                 if isinstance(result, (types.TextContent, types.ImageContent, types.EmbeddedResource)):
                      return [result]
                 elif isinstance(result, str):
                      return [types.TextContent(type="text", text=result)]
                 else:
                      logger.warning(f"Unexpected return type {type(result)} from mock tool '{key}', attempting str conversion.")
                      try:
                           return [types.TextContent(type="text", text=str(result))]
                      except Exception:
                           raise TypeError(f"Unsupported return type {type(result)} from mock tool '{key}'")
            # Ensure all items in the list are of the expected types
            return [
                item for item in result
                if isinstance(item, (types.TextContent, types.ImageContent, types.EmbeddedResource))
            ]

        except Exception as e:
             logger.error(f"Error calling mock tool '{key}': {e}", exc_info=True)
             raise # Re-raise the original error


    async def read_resource(
        self, uri: str | AnyUrl
    ) -> list[ReadResourceContents]: # Return type matches _mcp_read_resource
        """Directly read a resource or template by URI."""
        uri_str = str(uri)
        context = self.get_context()
        current_dependencies = self.dependencies.copy()
        current_dependencies[MockContext] = context # Allow injection

        # Check local manager (includes prefixed items)
        if self._resource_manager.has_resource(uri_str):
             resource = await self._resource_manager.get_resource(uri_str)
             try:
                 # ResourceManager.read_resource handles context injection now
                 content = await self._resource_manager.read_resource(
                     uri_str, dependencies=current_dependencies
                 )
                 return [ReadResourceContents(content=content, mime_type=resource.mime_type)]
             except Exception as e:
                 logger.error(f"Error reading mock resource {uri_str}: {e}", exc_info=True)
                 raise ResourceError(str(e))

        # Check templates
        elif template_match := await self._resource_manager.match_template(uri_str):
            template, params = template_match
            try:
                # ResourceManager.read_template handles context injection
                content = await self._resource_manager.read_template(
                    uri_str, params=params, dependencies=current_dependencies
                )
                return [ReadResourceContents(content=content, mime_type=template.mime_type)]
            except Exception as e:
                 logger.error(f"Error reading mock template resource {uri_str} (template: {template.uri_template}): {e}", exc_info=True)
                 raise ResourceError(str(e))
        else:
            raise NotFoundError(f"Unknown resource or template: {uri_str}")


    async def get_prompt(
        self, name: str, arguments: dict[str, Any] | None = None
    ) -> PromptResult: # Return the direct PromptResult
        """Directly render a prompt by name."""
        arguments = arguments or {}
        if not self._prompt_manager.has_prompt(name):
            raise NotFoundError(f"Unknown prompt: {name}")

        context = self.get_context()
        current_dependencies = self.dependencies.copy()
        current_dependencies[MockContext] = context # Allow injection

        try:
            # PromptManager.render_prompt handles context injection
            messages = await self._prompt_manager.render_prompt(
                name, arguments, context=context, dependencies=current_dependencies
            )
            return messages
        except Exception as e:
            logger.error(f"Error rendering mock prompt '{name}': {e}", exc_info=True)
            raise # Re-raise original error

    # --- Mocked Add Methods ---
    # Provide methods to add items directly to the mock's managers

    def add_tool(self, fn: AnyFunction, **kwargs):
        self._tool_manager.add_tool_from_fn(fn, **kwargs)
        self._cache.clear()

    def tool(
        self, name: str | None = None, **kwargs
    ) -> Callable[[AnyFunction], AnyFunction]:
        """Decorator to register a tool directly on the mock."""
        if callable(name):
             raise TypeError("Use @tool() instead of @tool")
        def decorator(fn: AnyFunction) -> AnyFunction:
            self.add_tool(fn, name=name, **kwargs)
            return fn
        return decorator

    def add_resource_fn(self, fn: AnyFunction, uri: str, **kwargs):
         self._resource_manager.add_resource_or_template_from_fn(fn=fn, uri=uri, **kwargs)
         self._cache.clear()

    def resource(
        self, uri: str, **kwargs
    ) -> Callable[[AnyFunction], AnyFunction]:
        """Decorator to register a resource directly on the mock."""
        if callable(uri):
             raise TypeError("Use @resource('uri') instead of @resource")
        def decorator(fn: AnyFunction) -> AnyFunction:
            self.add_resource_fn(fn=fn, uri=uri, **kwargs)
            return fn
        return decorator

    def add_prompt(self, fn: Callable[..., PromptResult | Awaitable[PromptResult]], **kwargs):
         self._prompt_manager.add_prompt_from_fn(fn=fn, **kwargs)
         self._cache.clear()

    def prompt(
        self, name: str | None = None, **kwargs
    ) -> Callable[[AnyFunction], AnyFunction]:
         """Decorator to register a prompt directly on the mock."""
         if callable(name):
              raise TypeError("Use @prompt() instead of @prompt")
         def decorator(func: AnyFunction) -> AnyFunction:
              self.add_prompt(func, name=name, **kwargs)
              return func
         return decorator


# --- Mapping Function ---

async def map_fastmcp_to_mock(
    server: FastMCP[LifespanResultT],
    _processed_servers: dict[int, MockFastMcp] | None = None # Use id() for cycle detection
) -> MockFastMcp[LifespanResultT]:
    """
    Creates a MockFastMcp instance from an existing FastMCP instance,
    copying its managers, lifespan context, and handling mounted servers.
    """
    if _processed_servers is None:
        _processed_servers = {}

    server_id = id(server)
    if server_id in _processed_servers:
        logger.debug(f"Detected cycle, returning existing mock for server id {server_id}")
        return _processed_servers[server_id]

    logger.debug(f"Mapping server '{server.name}' (id: {server_id}) to mock...")

    # --- 1. Handle Lifespan ---
    lifespan_context: LifespanResultT | object
    # Access the *original* lifespan function attached to the underlying MCPServer
    original_mcp_lifespan = server._mcp_server.lifespan
    mcp_server_instance = server._mcp_server

    # Determine if the lifespan needs the FastMCP instance or the MCPServer instance
    # The _lifespan_wrapper creates a closure expecting MCPServer,
    # but the user's original lifespan expects FastMCP.
    # We need to execute the *user's* original lifespan function.

    user_lifespan_func: Callable[[FastMCP], AbstractAsyncContextManager[LifespanResultT]] | None = None

    # Try to find the original user lifespan function if it was wrapped
    # This is a bit hacky, relying on inspection or assuming structure
    if hasattr(original_mcp_lifespan, "__closure__") and original_mcp_lifespan.__closure__:
        for cell in original_mcp_lifespan.__closure__:
             if isinstance(cell.cell_contents, FastMCP):
                 # Found the wrapped FastMCP instance (usually 'app'), get the original lifespan from it
                 # Need to find the original lifespan callable stored within the wrapper setup
                 # Let's search closure cells for a callable that isn't the wrapper itself
                 possible_lifespans = [
                      c.cell_contents for c in original_mcp_lifespan.__closure__
                      if callable(c.cell_contents) and c.cell_contents is not _lifespan_wrapper
                 ]
                 if len(possible_lifespans) == 1:
                      user_lifespan_func = possible_lifespans[0]
                      break

    # If we couldn't find it through closure inspection, maybe it wasn't wrapped (e.g., using default lifespan)
    # Or the original FastMCP object holds it directly? Check FastMCP source...
    # FastMCP's __init__ stores the user's lifespan before wrapping. Let's assume we can access it
    # if _lifespan_wrapper wasn't used, or find a way to get it.
    # For simplicity now, let's just execute the wrapped one if we can't easily get the original.

    # If we identified the user's lifespan function:
    if user_lifespan_func:
         logger.debug(f"Executing user lifespan function for '{server.name}'")
         try:
             async with AsyncExitStack() as stack:
                  ctx = await stack.enter_async_context(user_lifespan_func(server)) # Pass FastMCP instance
                  lifespan_context = ctx
         except Exception as e:
              logger.error(f"Failed to execute user lifespan for server '{server.name}' during mapping: {e}. Using empty context.", exc_info=True)
              lifespan_context = {}
    else:
         # Fallback: Execute the potentially wrapped lifespan expecting MCPServer
         logger.debug(f"Executing potentially wrapped lifespan function for '{server.name}'")
         try:
             async with AsyncExitStack() as stack:
                  ctx = await stack.enter_async_context(original_mcp_lifespan(mcp_server_instance)) # Pass MCPServer instance
                  lifespan_context = ctx
         except Exception as e:
              logger.error(f"Failed to execute wrapped lifespan for server '{server.name}' during mapping: {e}. Using empty context.", exc_info=True)
              lifespan_context = {}


    # --- 2. Create Mock Instance (and store to prevent cycles) ---
    mock_mcp = MockFastMcp[LifespanResultT](
        name=f"mock_{server.name}",
        instructions=server.instructions,
        lifespan_context=lifespan_context, # type: ignore
        settings=server.settings.model_dump(),
        tags=server.tags.copy(),
        dependencies=server.dependencies.copy(), # Copy dependencies
        # Initialize managers - they will be populated below
        tool_manager=ToolManager(duplicate_behavior=server._tool_manager.duplicate_behavior),
        resource_manager=ResourceManager(duplicate_behavior=server._resource_manager.duplicate_behavior),
        prompt_manager=PromptManager(duplicate_behavior=server._prompt_manager.duplicate_behavior),
    )
    _processed_servers[server_id] = mock_mcp # Store before processing children


    # --- 3. Copy Local Handlers (Tools, Resources, Prompts) ---
    logger.debug(f"Copying local handlers for '{server.name}'...")
    for key, tool in server._tool_manager.get_tools().items():
        mock_mcp._tool_manager.add_tool(tool, key=key)
    for key, resource in server._resource_manager.get_resources().items():
        mock_mcp._resource_manager.add_resource(resource, key=key)
    for key, template in server._resource_manager.get_templates().items():
        mock_mcp._resource_manager.add_template(template, key=key)
    for key, prompt in server._prompt_manager.get_prompts().items():
        mock_mcp._prompt_manager.add_prompt(prompt, key=key)

    # --- 4. Handle Mounted Servers ---
    # Recursively map mounted servers and add their items with prefixes
    logger.debug(f"Processing mounted servers for '{server.name}'...")
    for prefix, mounted_server_info in server._mounted_servers.items():
        mounted_server_instance = mounted_server_info.server
        logger.debug(f"Mapping mounted server '{mounted_server_instance.name}' with prefix '{prefix}'...")
        # Pass the _processed_servers dict to handle cycles in mounting
        mock_mounted_server = await map_fastmcp_to_mock(mounted_server_instance, _processed_servers)

        # Add mounted server's items to the current mock's managers with prefixes
        tool_prefix = f"{prefix}{mounted_server_info.tool_separator}"
        mounted_tools = await mock_mounted_server.get_tools() # Get from the *mocked* child
        logger.debug(f"Adding {len(mounted_tools)} tools from mounted mock '{mock_mounted_server.name}' with prefix '{tool_prefix}'")
        for key, tool in mounted_tools.items():
             mock_mcp._tool_manager.add_tool(tool, key=f"{tool_prefix}{key}")

        resource_prefix = f"{prefix}{mounted_server_info.resource_separator}"
        mounted_resources = await mock_mounted_server.get_resources()
        mounted_templates = await mock_mounted_server.get_resource_templates()
        logger.debug(f"Adding {len(mounted_resources)} resources and {len(mounted_templates)} templates from mounted mock '{mock_mounted_server.name}' with prefix '{resource_prefix}'")
        for key, resource in mounted_resources.items():
             mock_mcp._resource_manager.add_resource(resource, key=f"{resource_prefix}{key}")
        for key, template in mounted_templates.items():
             mock_mcp._resource_manager.add_template(template, key=f"{resource_prefix}{key}")

        prompt_prefix = f"{prefix}{mounted_server_info.prompt_separator}"
        mounted_prompts = await mock_mounted_server.get_prompts()
        logger.debug(f"Adding {len(mounted_prompts)} prompts from mounted mock '{mock_mounted_server.name}' with prefix '{prompt_prefix}'")
        for key, prompt in mounted_prompts.items():
             mock_mcp._prompt_manager.add_prompt(prompt, key=f"{prompt_prefix}{key}")


    # --- 5. Handle Imported Servers (Reflected in source server's managers) ---
    # The `import_server` method in FastMCP directly adds items to the managers.
    # Since we copied the *local* managers in step 3 and *then* handled mounted servers recursively,
    # items that were *imported* into the original `server` instance before mapping should already be included
    # in the managers copied in step 3. No extra step should be needed here specifically for imported items.
    logger.debug(f"Imported items (if any) are included from local manager copy for '{server.name}'.")


    logger.info(f"Mapped FastMCP Server '{server.name}' (id: {server_id}) to MockFastMcp '{mock_mcp.name}'")
    # Final counts after mounting/importing reflected
    logger.debug(f"Final Mock Tools Count: {len(await mock_mcp.get_tools())}")
    logger.debug(f"Final Mock Resources Count: {len(await mock_mcp.get_resources())}")
    logger.debug(f"Final Mock Templates Count: {len(await mock_mcp.get_resource_templates())}")
    logger.debug(f"Final Mock Prompts Count: {len(await mock_mcp.get_prompts())}")


    return mock_mcp
```

**Key Changes and Considerations:**

1.  **`MockContext`**: Provides a mock context object, primarily for accessing the `lifespan_context`. It includes basic logging methods and placeholders for other context functionalities. Real context methods relying on network/session state return `None` or raise errors.
2.  **`MockFastMcp`**:
    *   Stores core components like managers, lifespan context, settings, and dependencies.
    *   Uses a simplified `MockTimedCache`.
    *   `get_tools`, `get_resources`, etc., now directly access the internal managers. The assumption is that `map_fastmcp_to_mock` correctly populates these managers with both local and prefixed mounted/imported items.
    *   `call_tool`, `read_resource`, `get_prompt` now directly use the corresponding methods on the internal `ToolManager`, `ResourceManager`, `PromptManager`. These manager methods are responsible for finding the correct handler function and executing it.
    *   **Context Injection**: The direct call methods (`call_tool`, etc.) now prepare the `MockContext` and pass it along with other dependencies to the manager's execution methods (`call_tool`, `read_resource`, `read_template`, `render_prompt`). These manager methods use `solve_dependencies` (from `fastmcp.utilities.dependency_injection`) to inject the `MockContext` if the handler function requests it by type hint.
    *   **Return Types**: `call_tool` ensures the return value is wrapped in the expected list format. `read_resource` wraps the content in `ReadResourceContents`. `get_prompt` returns the direct `PromptResult`.
3.  **`map_fastmcp_to_mock`**:
    *   **Lifespan Handling**: Attempts to execute the original user-provided lifespan function (if it can be found) by passing the `FastMCP` instance. Falls back to executing the potentially wrapped lifespan if necessary.
    *   **Cycle Detection**: Uses `id(server)` and a `_processed_servers` dictionary to detect and handle circular mounts during recursive mapping.
    *   **Manager Copying**: Creates *new* manager instances for the mock and copies the registered items (tools, resources, templates, prompts) from the source server's *local* managers.
    *   **Mounting**: Recursively calls `map_fastmcp_to_mock` for mounted servers. It then takes the items from the *mocked* mounted server (using `get_tools`, etc.) and adds them to the *parent* mock's managers using the correct prefixes defined in the `MountedServer` info.
    *   **Importing**: Items imported into the original `FastMCP` server *before* mapping are part of its managers and thus get copied naturally in step 3. No separate handling is needed.
    *   **Dependencies**: Copies the `dependencies` dictionary from the source server.

This provides a way to create a mock version of a `FastMCP` server, preserving its handlers, lifespan context, mounted structure (with prefixes), and allowing direct invocation of its functionality without network overhead.

---

_**User**_

@main1.py 报错了，请分析原因并修复,,另外请注意并没有fastmcp.utilities.dependency_injection.solve_dependencies,下面是我觉得可能有助于你理解完整代码的相关代码：@settings.py @context.py 

---

_**Assistant**_



---

好的，我们来分析并修复 `main1.py` 中的报错。

**错误分析**

正如你提供的 traceback 所示，错误是：

```
TypeError: ToolManager.call_tool() got an unexpected keyword argument 'dependencies'
```

这个错误发生在 `mock_fastmcp.py` 文件中 `MockFastMcp.call_tool` 方法内部，当我们尝试调用 `self._tool_manager.call_tool(...)` 时。

原因在于：

1.  在 `MockFastMcp.call_tool`（以及 `read_resource`, `get_prompt`）中，我们创建了一个 `MockContext`。
2.  我们试图将一个名为 `dependencies` 的字典（包含 `MockContext`）传递给 `ToolManager.call_tool`。
3.  然而，`fastmcp` 库中实际的 `ToolManager.call_tool` 方法（以及 `ResourceManager` 和 `PromptManager` 的相应方法）并不接受一个名为 `dependencies` 的关键字参数。它们通常只接受一个 `context` 参数（即我们创建的 `MockContext` 或实际的 `Context` 对象）。
4.  依赖注入（将 `Context` 对象提供给请求它的处理器函数）是由 `ToolManager`（或 `ResourceManager`/`PromptManager`）内部处理的，而不是通过向其 `call_tool` 方法传递 `dependencies` 字典来完成的。

**修复方案**

我们需要修改 `MockFastMcp` 中的 `call_tool`, `read_resource`, 和 `get_prompt` 方法，不再传递 `dependencies` 参数，而是将创建的 `MockContext` 对象作为 `context` 参数传递给相应的管理器方法。

**代码修改**

请在 `mock_fastmcp.py` 文件中进行以下修改：

1.  **修改 `MockFastMcp.call_tool`**:

    ```python:mock_fastmcp.py
    # ... inside MockFastMcp class ...

        async def call_tool(
            self, key: str, arguments: dict[str, Any] | None = None
        ) -> list[types.TextContent | types.ImageContent | types.EmbeddedResource]:
            """Directly call a tool by key."""
            arguments = arguments or {}
            if not self._tool_manager.has_tool(key):
                raise NotFoundError(f"Unknown tool: {key}")

            context = self.get_context() # Create the MockContext
            # Use the ToolManager's call_tool which handles context injection via solve_dependencies
            try:
                # Pass the mock context object directly as the 'context' argument
                result = await self._tool_manager.call_tool(
                    key,
                    arguments,
                    context=context # Pass the created MockContext here
                    # REMOVED: dependencies=current_dependencies
                )

                # Ensure result is in the expected list format (similar to FastMCP handler)
                if not isinstance(result, list):
                     if isinstance(result, (types.TextContent, types.ImageContent, types.EmbeddedResource)):
                          return [result]
                     elif isinstance(result, str):
                          return [types.TextContent(type="text", text=result)]
                     else:
                          logger.warning(f"Unexpected return type {type(result)} from mock tool '{key}', attempting str conversion.")
                          try:
                               return [types.TextContent(type="text", text=str(result))]
                          except Exception:
                               raise TypeError(f"Unsupported return type {type(result)} from mock tool '{key}'")
                # Ensure all items in the list are of the expected types
                return [
                    item for item in result
                    if isinstance(item, (types.TextContent, types.ImageContent, types.EmbeddedResource))
                ]

            except Exception as e:
                 logger.error(f"Error calling mock tool '{key}': {e}", exc_info=True)
                 # Propagate specific FastMCP errors if needed, otherwise re-raise
                 if isinstance(e, (NotFoundError, ResourceError)):
                     raise e
                 # You might want to wrap other exceptions in a generic error
                 # or just re-raise the original error for easier debugging in mock environment
                 raise # Re-raise the original error
    ```

2.  **修改 `MockFastMcp.read_resource`**:

    ```python:mock_fastmcp.py
    # ... inside MockFastMcp class ...

        async def read_resource(
            self, uri: str | AnyUrl
        ) -> list[ReadResourceContents]: # Return type matches _mcp_read_resource
            """Directly read a resource or template by URI."""
            uri_str = str(uri)
            context = self.get_context() # Create MockContext

            # Check local manager (includes prefixed items)
            if self._resource_manager.has_resource(uri_str):
                 resource = await self._resource_manager.get_resource(uri_str)
                 try:
                     # Pass MockContext as 'context' to read_resource if it accepts it
                     # Assuming ResourceManager.read_resource handles injection internally
                     # Check the actual signature if unsure. If it doesn't take context, remove it.
                     # Let's assume it might need context for dependency solving:
                     content = await self._resource_manager.read_resource(
                         uri_str, context=context # Pass context here
                         # REMOVED: dependencies=current_dependencies
                     )
                     return [ReadResourceContents(content=content, mime_type=resource.mime_type)]
                 except Exception as e:
                     logger.error(f"Error reading mock resource {uri_str}: {e}", exc_info=True)
                     raise ResourceError(str(e))

            # Check templates
            elif template_match := await self._resource_manager.match_template(uri_str):
                template, params = template_match
                try:
                    # Pass MockContext as 'context' to read_template if it accepts it
                    # Assuming ResourceManager.read_template handles injection internally
                    content = await self._resource_manager.read_template(
                        uri_str, params=params, context=context # Pass context here
                        # REMOVED: dependencies=current_dependencies
                    )
                    return [ReadResourceContents(content=content, mime_type=template.mime_type)]
                except Exception as e:
                     logger.error(f"Error reading mock template resource {uri_str} (template: {template.uri_template}): {e}", exc_info=True)
                     raise ResourceError(str(e))
            else:
                raise NotFoundError(f"Unknown resource or template: {uri_str}")
    ```

3.  **修改 `MockFastMcp.get_prompt`**:

    ```python:mock_fastmcp.py
    # ... inside MockFastMcp class ...

        async def get_prompt(
            self, name: str, arguments: dict[str, Any] | None = None
        ) -> PromptResult: # Return the direct PromptResult
            """Directly render a prompt by name."""
            arguments = arguments or {}
            if not self._prompt_manager.has_prompt(name):
                raise NotFoundError(f"Unknown prompt: {name}")

            context = self.get_context() # Create MockContext

            try:
                # Pass MockContext as 'context' to render_prompt
                # Assuming PromptManager.render_prompt handles injection internally
                messages = await self._prompt_manager.render_prompt(
                    name, arguments, context=context # Pass context here
                    # REMOVED: dependencies=current_dependencies
                )
                return messages
            except Exception as e:
                logger.error(f"Error rendering mock prompt '{name}': {e}", exc_info=True)
                raise # Re-raise original error
    ```

**关于 `solve_dependencies`**

你说得对，之前的假设 `fastmcp.utilities.dependency_injection.solve_dependencies` 存在是不正确的。`FastMCP` 内部处理依赖注入的方式（特别是将 `Context` 注入到处理器函数）可能封装在 `ToolManager`、`ResourceManager` 和 `PromptManager` 的 `call_tool`/`read_resource`/`render_prompt` 方法中，或者直接在获取处理器函数后、调用之前进行处理。

通过上述修改，我们将 `MockContext` 传递给了这些管理器方法，模拟了真实 `FastMCP` 的行为。现在，只要 `fastmcp` 库本身的管理器类能够正确处理传入的 `context` 参数并执行依赖注入，我们的 `MockFastMcp` 就能正常工作。

**总结**

错误的原因是向管理器方法传递了不被接受的 `dependencies` 参数。修复方法是移除这个参数，并将创建的 `MockContext` 作为 `context` 参数传递，这与 `FastMCP` 的实际工作方式一致。进行这些修改后，`main1.py` 应该可以正常运行。

---

_**User**_

好的，请编写测试详细地测试mockmcp和mockfastmcp,然后编写markdown格式的使用教程文档

---

_**Assistant**_



---



---

